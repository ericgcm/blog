
 

1、生成core dump文件的方法：

  $  ulimit -c //查看是否为0

    如果为0

 $   ulimit -c unlimited

    这样在程序崩溃以后会在当前目录生成一个core.xxxx的文件

 

2、调试core dump文件

    生成了core.xxx文件以后

  $  gdb ./应用程序  core.xxxx

  就会恢复现场到你的程序崩溃的那一刻

 (gdb)bt          //这个命令会列出程序崩溃时的堆栈信息，一层一层会有标号  #0  #1  #2 .......

  如果你要查看某一层的信息，你需要在切换当前的栈，一般来说，程序停止时，最顶层的栈就是当前栈，如果你要查看栈下面层的详细信息，首先要做的是切换到你想看的栈

（gdb）f  N    //N是你想要切换的栈的标号，达到后可以用  ‘p  变量’  查看变量的值，以查找异常出现的原因

 

     info args
        打印出当前函数的参数名及其值。
    
     info locals
        打印出当前函数中所有局部变量及其值。
       
     info catch
        打印出当前的函数中的异常处理信息。

 

3、gdb调试命令

 

 l  列出此刻运行到代码行的函数的上下文代码

 b  设置断点

 r  开始运行程序

 s  单步调试，进入函数

 n  单步，不进入下一层函数

 n  k（一个数字） 这样是相当于输入了k次n，也就是走了k步

 c  继续运行程序（一般是跑到断点后，跟了几步，输入c继续往下一个断点跑）

[enter]  回车键默认执行上一次的命令

finish     执行完当前函数返回到调用他的函数，例如单步执行如果进入到了某函数，但你又想退出该函数

u（until） 制定程序直到退出当前的循环体，输入u自动执行完全部的循环

break 34 if  var=12     //设置条件断点，当var等于12的时候就在34行设置断点watch i != 10      //监控某一个条件，然后设置断点，如果i不等于10的时候，就设置断点

break  func      //为某一个函数设置断点

break  filename:N      //在某一个文件的第N行设置断点

info breakpoints         显示所有的断点的信息

delete N          //删除标号为N的断点

delete        删除所有的断点

clear  N    //清楚N上面的所有的断点

p    var     打印变量var的值

//打印字符串的时候，有长度限制，想打印完整的长字符串，通过命令set print element 0就可以了

p   /x var     以16进制显示var的值

                   x 16进制

                   d 10进制

                   t   二进制

                   c   按字符格式显示变量

                   f    按浮点数

print *a@10         //如果a是一个数组，这样显示数据的10个元素的值

print   var=10       //修改运行时变量的值

whatis  var          //显示一个变量的类型

ptype var           //更详细的方式显示变量var的类型，会打印出var的结构定义

 

4、编译的时候要加入-g选项，才可以对程序进行跟踪

 

5、gdb调试程序的时候打印变量值会出现<value optimized out> 情况,可以在gcc编译的时候加上 -O0参数项,意思是不进行编译优化,调试的时候就会顺畅了,运行流程不会跳来跳去的,发布项目的时候记得不要在使用 -O0参数项,gcc 默认编译或加上-O2优化编译会提高程序运行速度
